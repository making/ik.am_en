---
title: Kubernetes Hands-on - 10. Controlling Kubernetes API Access with RBAC
tags: ["Kubernetes Handson", "Kubernetes", "PKS"]
categories: ["Dev", "CaaS", "Kubernetes"]
date: 2020-01-13T13:43:16Z
updated: 2022-11-08T07:28:22Z
---

> ⚠️ This article was automatically translated by OpenAI (gpt-4o).
> It may be edited eventually, but please be aware that it may contain incorrect information at this time.

Operations on Kubernetes are performed against the API Server on the Master Node. To restrict this API access, Kubernetes is equipped with a mechanism called RBAC (Role-Based Access Control).

In Kubernetes RBAC, resources are provided to express which operations (get, list, create, delete, etc.) are allowed on which resources (Pod, ReplicaSet, Deployment, Service, etc.):

* Role
* ClusterRole

Roles are applied under a specific namespace. On the other hand, ClusterRoles are applied to the entire Kubernetes cluster regardless of the namespace. ClusterRoles can also control access to cluster-scoped resources like nodes and non-resource endpoints like `/healthz`.

There are three types of subjects to which Roles/ClusterRoles can be bound:

* User
* Group
* ServiceAccount

A User refers to a human accessing the Kubernetes API. A Group is a collection of Users. On the other hand, a ServiceAccount is intended for processes running in containers that access the Kubernetes API. ServiceAccounts are created for specific namespaces.

Kubernetes does not have a feature to create users or groups. The management of users/groups is delegated to external systems and integrated via mechanisms like OpenID Connect. This document only deals with ServiceAccounts.

To bind a Role to a subject, the following resources are provided:

* RoleBinding
* ClusterRoleBinding

RoleBindings bind a Role or ClusterRole to a subject for resources in a specific namespace. ClusterRoleBindings bind a ClusterRole to a subject for resources in any namespace or cluster-scoped resources and non-resource endpoints like `/healthz`.

RBAC uses a whitelist approach where rules are added to allow access. Rules to deny access cannot be specified.

**Table of Contents**

<!-- toc -->

### Accessing the Kubernetes API with curl

To explain RBAC, we will use the `curl` command as the simplest client to access the Kubernetes API.

The Kubernetes API is exposed as a Service named `kubernetes` in the `default` namespace.

```
kubectl get svc kubernetes -n default
```
Output
```
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.11.240.1   <none>        443/TCP   170d
```

Using internal DNS (KubeDNS), you can access it from within a Pod's container using the hostname `kubernetes.default.svc.cluster.local` as follows:

```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local
```

`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt` contains the CA certificate for the Kubernetes API, and `/var/run/secrets/kubernetes.io/serviceaccount/token` contains the token (JWT) for the ServiceAccount assigned to the Pod.

First, create a namespace called `demo-pks` for the work.

Create `demo-pks-ns.yml` with the following content:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: demo-pks
```
Create the `demo-pks` namespace with the following command:
```
kubectl apply -f demo-pks-ns.yml
```
Output
```
namespace "demo-pks" created
```

Next, deploy a Pod containing the `curl` command in the `demo-pks` namespace.

Create `curl.yml` with the following content:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: curl
  namespace: demo-pks
spec:
  replicas: 1
  selector:
    matchLabels:
      app: curl
  template:
    metadata:
      labels:
        app: curl
    spec:
      containers:
      - image: tutum/curl
        name: sleep
        command:
        - sh
        - -c
        - |
          while true;do sleep 1;done
```

The process is made to sleep indefinitely to prevent it from terminating. Deploy it with the following command:
```
kubectl apply -f curl.yml
```
Output
```
deployment "curl" created
```

Check the list of Pods in the `demo-pks` namespace with the following command:

```
kubectl get pod -n demo-pks
```
Output
```
NAME                   READY     STATUS    RESTARTS   AGE
curl-997d489df-8lvqp   1/1       Running   0          7s
```
Execute bash on the container with the following command:
```
kubectl exec -n demo-pks -ti $(kubectl get pod -n demo-pks -l app=curl -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}') /bin/bash
```
From the bash on the container, execute the following command to access the API to get the list of Pods in the `demo-pks` namespace:
```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/demo-pks/pods
```
Output
```json
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {
    
  },
  "status": "Failure",
  "message": "pods is forbidden: User \"system:serviceaccount:demo-pks:default\" cannot list pods in the namespace \"demo-pks\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}
```

Execute `exit` to exit the bash on the container.

By default, the ServiceAccount named `default` is used. You can check the ServiceAccount in the `demo-pks` namespace with the following command:
```
kubectl get serviceaccount -n demo-pks
```
Output
```
NAME      SECRETS   AGE
default   1         4m
```

The `default` ServiceAccount **does not have permission to access the Kubernetes API**, hence the 403 error.

### Creating ServiceAccount, Role, and RoleBinding

To allow retrieving the list of Pods in the `demo-pks` namespace, create a ServiceAccount named `demo-sa` and bind it to a Role named `demo-reader`.

Create `demo-rbac.yml` with the following content:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: demo-sa
  namespace: demo-pks
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: demo-reader
  namespace: demo-pks
rules:
- apiGroups: 
  - "" # "" indicates the core API group
  resources:
  - pods
  verbs:
  - get
  - watch
  - list
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: demo-sa-binding
  namespace: demo-pks
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: demo-reader
subjects:
- kind: ServiceAccount
  name: demo-sa
  namespace: demo-pks
```

Execute the following command to create the ServiceAccount, Role, and RoleBinding:
```
kubectl apply -f demo-rbac.yml
```
Output
```
serviceaccount "demo-sa" created
role "demo-reader" created
rolebinding "demo-sa-binding" created
```

Modify `curl.yml` to use this `demo-sa` ServiceAccount as follows:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: curl
  namespace: demo-pks
spec:
  replicas: 1
  selector:
    matchLabels:
      app: curl
  template:
    metadata:
      labels:
        app: curl
    spec:
      serviceAccountName: demo-sa # Added
      containers:
      - image: tutum/curl
        name: sleep
        command:
        - sh
        - -c
        - |
          while true;do sleep 1;done
```

Execute the following command to update the Pod:

```
kubectl apply -f curl.yml
```
Output
```
deployment "curl" configured
```

Execute bash on the container again with the following command:

```
kubectl exec -n demo-pks -ti $(kubectl get pod -n demo-pks -l app=curl -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}') /bin/bash
```
From the bash on the container, execute the following command to access the API to get the list of Pods in the `demo-pks` namespace:
```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/demo-pks/pods
```
Output
```json
{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "selfLink": "/api/v1/namespaces/demo-pks/pods",
    "resourceVersion": "139492"
  },
  "items": [
    {
      ...
    }
  ]
}
```

Since the `demo-reader` Role only has read permissions for Pods, it cannot access, for example, the API to get the list of Services.

From the bash on the container, execute the following command to access the API to get the list of Services in the `demo-pks` namespace:

```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/demo-pks/services
```
Output
```json
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {
    
  },
  "status": "Failure",
  "message": "services is forbidden: User \"system:serviceaccount:demo-pks:demo-sa\" cannot list services in the namespace \"demo-pks\"",
  "reason": "Forbidden",
  "details": {
    "kind": "services"
  },
  "code": 403
}
```
Execute `exit` to exit the bash on the container.

Modify `demo-rbac.yml` to add read permissions for the Service resource as follows:

```yaml
# ...
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: demo-reader
rules:
- apiGroups: 
  - "" # "" indicates the core API group
  resources:
  - pods
  - services # Added
  verbs:
  # ...
```

Execute the following command to update the Role:
```
kubectl apply -f demo-rbac.yml
```
Output
```
serviceaccount "demo-sa" unchanged
role "demo-reader" configured
rolebinding "demo-sa-binding" unchanged
```

Execute bash on the container again with the following command:

```
kubectl exec -n demo-pks -ti $(kubectl get pod -n demo-pks -l app=curl -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}') /bin/bash
```
From the bash on the container, execute the following command to access the API to get the list of Services in the `demo-pks` namespace:
```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/demo-pks/services
```
Output
```json
{
  "kind": "ServiceList",
  "apiVersion": "v1",
  "metadata": {
    "selfLink": "/api/v1/namespaces/demo-pks/services",
    "resourceVersion": "140006"
  },
  "items": []
}
```

We have confirmed that the Role has been extended.

### Using ClusterRole

Roles need to be created for each namespace. Creating access control for each resource in each namespace is cumbersome. A ClusterRole can be used in any namespace within the same cluster. You can create your own ClusterRole or use the pre-defined ones.

Execute the following command to check the list of pre-defined ClusterRoles:
```
kubectl get clusterrole
```
Output
``` 
NAME                                                                   AGE
admin                                                                  2d
cluster-admin                                                          2d
edit                                                                   2d
kubo:internal:kubelet-drain                                            2d
kubo:route-sync                                                        2d
nginx-ingress-clusterrole                                              22h
system:aggregate-to-admin                                              2d
system:aggregate-to-edit                                               2d
system:aggregate-to-view                                               2d
system:auth-delegator                                                  2d
system:aws-cloud-provider                                              2d
system:basic-user                                                      2d
system:certificates.k8s.io:certificatesigningrequests:nodeclient       2d
system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   2d
system:controller:attachdetach-controller                              2d
system:controller:certificate-controller                               2d
system:controller:clusterrole-aggregation-controller                   2d
system:controller:cronjob-controller                                   2d
system:controller:daemon-set-controller                                2d
system:controller:deployment-controller                                2d
system:controller:disruption-controller                                2d
system:controller:endpoint-controller                                  2d
system:controller:generic-garbage-collector                            2d
system:controller:horizontal-pod-autoscaler                            2d
system:controller:job-controller                                       2d
system:controller:namespace-controller                                 2d
system:controller:node-controller                                      2d
system:controller:persistent-volume-binder                             2d
system:controller:pod-garbage-collector                                2d
system:controller:pv-protection-controller                             2d
system:controller:pvc-protection-controller                            2d
system:controller:replicaset-controller                                2d
system:controller:replication-controller                               2d
system:controller:resourcequota-controller                             2d
system:controller:route-controller                                     2d
system:controller:service-account-controller                           2d
system:controller:service-controller                                   2d
system:controller:statefulset-controller                               2d
system:controller:ttl-controller                                       2d
system:discovery                                                       2d
system:heapster                                                        2d
system:kube-aggregator                                                 2d
system:kube-controller-manager                                         2d
system:kube-dns                                                        2d
system:kube-scheduler                                                  2d
system:node                                                            2d
system:node-bootstrapper                                               2d
system:node-problem-detector                                           2d
system:node-proxier                                                    2d
system:persistent-volume-provisioner                                   2d
view 
```

Those starting with `system:` are ClusterRoles used by specific components. The following four are generally available ClusterRoles:

* `cluster-admin`
* `admin`
* `edit`
* `view`

Refer to the [documentation](https://kubernetes.io/docs/admin/authorization/rbac/#user-facing-roles) for descriptions of each.

Here, we will bind the `view` ClusterRole, which has read permissions for many resources, to the `demo-sa` ServiceAccount.

Create `demo-sa-edit-binding.yml` with the following content:

```yaml
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: demo-sa-edit-binding
  namespace: demo-pks
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: ServiceAccount
  name: demo-sa
  namespace: demo-pks
```

Create the RoleBinding with the following command:

```
kubectl apply -f demo-sa-edit-binding.yml 
```
Output
```
rolebinding "demo-sa-edit-binding" created
```

Execute bash on the container again with the following command:

```
kubectl exec -n demo-pks -ti $(kubectl get pod -n demo-pks -l app=curl -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}') /bin/bash
```

From the bash on the container, execute the following command to access the API to get the list of Deployments in the `demo-pks` namespace:

```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/apis/extensions/v1beta1/namespaces/demo-pks/deployments
```
Output
```json
{
  "kind": "DeploymentList",
  "apiVersion": "extensions/v1beta1",
  "metadata": {
    "selfLink": "/apis/extensions/v1beta1/namespaces/demo-pks/deployments",
    "resourceVersion": "142427"
  },
  "items": [
    {
      ...
    }
  ]
}
```
You can see that the accessible APIs have increased.

However, even with a ClusterRole, the scope of the RoleBinding is still limited to a specific namespace. For example, you cannot access the list of Pods in a different namespace. Execute the following command to access the API to get the list of Pods in the `kube-system` namespace:

```
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/kube-system/pods
```
Output
```json
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {
    
  },
  "status": "Failure",
  "message": "pods is forbidden: User \"system:serviceaccount:demo-pks:demo-sa\" cannot list pods in the namespace \"kube-system\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}
```

Delete the `demo-sa-edit-binding`.

```
kubectl delete -f demo-sa-edit-binding.yml
