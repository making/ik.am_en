---
title: Notes on Installing Tanzu Application Platform 1.9 (Full Profile) on EKS
tags: ["Kubernetes", "Cartographer", "EKS", "ECR", "Tanzu", "TAP"]
categories: ["Dev", "CaaS", "Kubernetes", "TAP"]
date: 2024-04-19T02:22:20Z
updated: 2024-04-19T04:20:37Z
---

> ⚠️ This article was automatically translated by OpenAI (gpt-4o).
> It may be edited eventually, but please be aware that it may contain incorrect information at this time.

```
cat <<'EOF' > tap.tf
provider "aws" {
  region = "ap-northeast-1"
}


variable "project_prefix" {
  description = "Prefix for resource names to indicate the project and environment"
  type        = string
  default     = "tap-sandbox"
}


resource "aws_vpc" "tap_vpc" {
  cidr_block = "10.0.0.0/16"
  tags = {
    Name = "${var.project_prefix}-vpc"
  }
}

resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.tap_vpc.id
}

# Public Subnets
resource "aws_subnet" "public_subnet" {
  count                   = 3
  vpc_id                  = aws_vpc.tap_vpc.id
  cidr_block              = ["10.0.0.0/23", "10.0.2.0/23", "10.0.4.0/23"][count.index]
  availability_zone       = element(["ap-northeast-1a", "ap-northeast-1c", "ap-northeast-1d"], count.index % 3)
  map_public_ip_on_launch = true
  tags = {
    Name = "${var.project_prefix}-public-subnet-${count.index + 1}"
    "kubernetes.io/role/elb" = "1"
  }
}

resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.tap_vpc.id
}

resource "aws_route" "public_route" {
  route_table_id         = aws_route_table.public_rt.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.igw.id
}

resource "aws_route_table_association" "public_rta" {
  count          = 3
  subnet_id      = aws_subnet.public_subnet[count.index].id
  route_table_id = aws_route_table.public_rt.id
}

# Private Subnets
resource "aws_subnet" "private_subnet" {
  count             = 6
  vpc_id            = aws_vpc.tap_vpc.id
  cidr_block        = ["10.0.8.0/22", "10.0.12.0/22", "10.0.16.0/22", "10.0.20.0/23", "10.0.22.0/23", "10.0.24.0/23"][count.index]
  availability_zone = element(["ap-northeast-1a", "ap-northeast-1c", "ap-northeast-1d"], count.index % 3)
  tags = {
    Name = "${var.project_prefix}-private-${element(["tap-1", "tap-2", "tap-3", "db-1", "db-2", "db-3"], count.index)}"
  }
}

# Public NAT Gateway for Private Subnets
resource "aws_eip" "tap_nat_eip" {
  domain = "vpc"
  tags = {
    Name = "${var.project_prefix}-tap-nat-eip"
  }
}

resource "aws_nat_gateway" "tap_nat" {
  allocation_id = aws_eip.tap_nat_eip.id
  subnet_id     = aws_subnet.public_subnet[0].id
  tags = {
    Name = "${var.project_prefix}-tap-nat"
  }
}

# Route tables for tap-1, tap-2, tap-3 subnets to use the Private NAT Gateway
resource "aws_route_table" "private_tap_rt" {
  count  = 3 # For tap-1, tap-2, tap-3
  vpc_id = aws_vpc.tap_vpc.id
  tags = {
    Name = "${var.project_prefix}-private-tap-${count.index}-rt"
  }
}

resource "aws_route" "tap_private_route" {
  count                  = 3 # For tap-1, tap-2, tap-3
  route_table_id         = element(aws_route_table.private_tap_rt.*.id, count.index)
  destination_cidr_block = "0.0.0.0/0"
  nat_gateway_id         = aws_nat_gateway.tap_nat.id
}

resource "aws_route_table_association" "tap_rta" {
  count          = 3 # For tap-1, tap-2, tap-3
  subnet_id      = element(aws_subnet.private_subnet.*.id, count.index) # Adjust indices for tap-1, tap-2, tap-3
  route_table_id = element(aws_route_table.private_tap_rt.*.id, count.index)
}

resource "aws_security_group" "allow_postgres" {
  name        = "${var.project_prefix}-allow-postgres"
  description = "Allow PostgreSQL traffic from tap-1, tap-2, tap-3 subnets on port 5432"
  vpc_id      = aws_vpc.tap_vpc.id

  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = [aws_subnet.private_subnet[0].cidr_block, aws_subnet.private_subnet[1].cidr_block, aws_subnet.private_subnet[2].cidr_block]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.project_prefix}-allow-postgres"
  }
}

resource "aws_db_subnet_group" "db_subnet_group" {
  name        = "${var.project_prefix}-db-subnet-group"
  description = "RDS DB Subnet Group for db-1, db-2, db-3 subnets"
  subnet_ids  = [aws_subnet.private_subnet[3].id, aws_subnet.private_subnet[4].id, aws_subnet.private_subnet[5].id]

  tags = {
    Name = "${var.project_prefix}-db-subnet-group"
  }
}

resource "aws_s3_bucket" "techdocs_bucket" {
  bucket = "${var.project_prefix}-techdocs"

  tags = {
    Name = "${var.project_prefix}-techdocs"
  }
}

resource "aws_s3_bucket_versioning" "techdocs_bucket_versioning" {
  bucket = aws_s3_bucket.techdocs_bucket.id

  versioning_configuration {
    status = "Enabled"
  }
}
EOF
```

```
terraform init
terraform plan -out plan
terraform apply plan
```

```
cat <<EOF > ../vars.sh
export VPC_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "tap_vpc").instances[0].attributes.id')
export PUBLIC_SUBNET_1_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[0].attributes.id')
export PUBLIC_SUBNET_1_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[0].attributes.availability_zone')
export PUBLIC_SUBNET_2_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[1].attributes.id')
export PUBLIC_SUBNET_2_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[1].attributes.availability_zone')
export PUBLIC_SUBNET_3_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[2].attributes.id')
export PUBLIC_SUBNET_3_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "public_subnet").instances[2].attributes.availability_zone')
export PRIVATE_SUBNET_1_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[0].attributes.id')
export PRIVATE_SUBNET_1_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[0].attributes.availability_zone')
export PRIVATE_SUBNET_2_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[1].attributes.id')
export PRIVATE_SUBNET_2_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[1].attributes.availability_zone')
export PRIVATE_SUBNET_3_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[2].attributes.id')
export PRIVATE_SUBNET_3_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[2].attributes.availability_zone')
export PRIVATE_SUBNET_4_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[3].attributes.id')
export PRIVATE_SUBNET_4_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[3].attributes.availability_zone')
export PRIVATE_SUBNET_5_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[4].attributes.id')
export PRIVATE_SUBNET_5_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[4].attributes.availability_zone')
export PRIVATE_SUBNET_6_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[5].attributes.id')
export PRIVATE_SUBNET_6_AZ=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "private_subnet").instances[5].attributes.availability_zone')
export DB_SG_ID=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "allow_postgres").instances[0].attributes.id')
export DB_SUBNET_GROUP_NAME=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "db_subnet_group").instances[0].attributes.name')
export TECHDOCS_BUCKET_NAME=$(cat terraform.tfstate | jq -r '.resources[] | select(.name == "techdocs_bucket").instances[0].attributes.bucket')
EOF

cd ..


source vars.sh
```

```yaml
cat <<EOF > eks-cluster-config.yaml
---
kind: ClusterConfig
apiVersion: eksctl.io/v1alpha5
metadata:
  name: tap-sandbox
  region: ap-northeast-1
  version: "1.28"
managedNodeGroups:
- name: tap-sandbox-ng-1
  minSize: 3
  maxSize: 3
  desiredCapacity: 3
  volumeSize: 200
  maxPodsPerNode: 110
  instanceType: c5.xlarge
  privateNetworking: true
  spot: false
  ssh:
    allow: true
    publicKeyPath: ~/.ssh/id_rsa.pub
addons:
- name: aws-ebs-csi-driver
  wellKnownPolicies:
    ebsCSIController: true
iam:
  withOIDC: true
vpc:
  id: ${VPC_ID}
  subnets:
    private:
      ${PRIVATE_SUBNET_1_AZ}:
        id: ${PRIVATE_SUBNET_1_ID}
      ${PRIVATE_SUBNET_2_AZ}:
        id: ${PRIVATE_SUBNET_2_ID}
      ${PRIVATE_SUBNET_3_AZ}:
        id: ${PRIVATE_SUBNET_3_ID}
---
EOF
```

```
eksctl create cluster -f eks-cluster-config.yaml
```

```
$ kubectl get node -owide
NAME                                             STATUS   ROLES    AGE     VERSION               INTERNAL-IP   EXTERNAL-IP   OS-IMAGE         KERNEL-VERSION                  CONTAINER-RUNTIME
ip-10-0-12-228.ap-northeast-1.compute.internal   Ready    <none>   4m58s   v1.28.5-eks-5e0fdde   10.0.12.228   <none>        Amazon Linux 2   5.10.213-201.855.amzn2.x86_64   containerd://1.7.11
ip-10-0-19-37.ap-northeast-1.compute.internal    Ready    <none>   5m31s   v1.28.5-eks-5e0fdde   10.0.19.37    <none>        Amazon Linux 2   5.10.213-201.855.amzn2.x86_64   containerd://1.7.11
ip-10-0-8-251.ap-northeast-1.compute.internal    Ready    <none>   5m37s   v1.28.5-eks-5e0fdde   10.0.8.251    <none>        Amazon Linux 2   5.10.213-201.855.amzn2.x86_64   containerd://1.7.11


$ kubectl get nodes -o=custom-columns='NAME:.metadata.name,INSTANCE-TYPE:.metadata.labels.beta\.kubernetes\.io/instance-type,CAPACITY-TYPE:.metadata.labels.eks\.amazonaws\.com/capacityType,ZONE:.metadata.labels.failure-domain\.beta\.kubernetes\.io/zone'
NAME                                             INSTANCE-TYPE   CAPACITY-TYPE   ZONE
ip-10-0-12-228.ap-northeast-1.compute.internal   c5.xlarge       ON_DEMAND       ap-northeast-1c
ip-10-0-19-37.ap-northeast-1.compute.internal    c5.xlarge       ON_DEMAND       ap-northeast-1d
ip-10-0-8-251.ap-northeast-1.compute.internal    c5.xlarge       ON_DEMAND       ap-northeast-1a
```

```
export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
export AWS_REGION=ap-northeast-1
export EKS_CLUSTER_NAME=tap-sandbox
```


```
aws ecr create-repository --repository-name tap-images --region $AWS_REGION
aws ecr create-repository --repository-name tap-build-service --region $AWS_REGION

aws ecr create-repository --repository-name full-deps-package-repo --region $AWS_REGION
aws ecr create-repository --repository-name tap-lsp --region $AWS_REGION
aws ecr create-repository --repository-name tanzu-cluster-essentials --region $AWS_REGION
```


```
# Retrieve the OIDC endpoint from the Kubernetes cluster and store it for use in the policy.
export OIDCPROVIDER=$(aws eks describe-cluster --name $EKS_CLUSTER_NAME --region $AWS_REGION --output json | jq '.cluster.identity.oidc.issuer' | tr -d '"' | sed 's/https:\/\///')

cat << EOF > build-service-trust-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/${OIDCPROVIDER}"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "${OIDCPROVIDER}:aud": "sts.amazonaws.com"
                },
                "StringLike": {
                    "${OIDCPROVIDER}:sub": [
                        "system:serviceaccount:kpack:controller",
                        "system:serviceaccount:build-service:dependency-updater-controller-serviceaccount"
                    ]
                }
            }
        }
    ]
}
EOF

cat << EOF > build-service-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Action": [
                "ecr:DescribeRegistry",
                "ecr:GetAuthorizationToken",
                "ecr:GetRegistryPolicy",
                "ecr:PutRegistryPolicy",
                "ecr:PutReplicationConfiguration",
                "ecr:DeleteRegistryPolicy"
            ],
            "Resource": "*",
            "Effect": "Allow",
            "Sid": "TAPEcrBuildServiceGlobal"
        },
        {
            "Action": [
                "ecr:DescribeImages",
                "ecr:ListImages",
                "ecr:BatchCheckLayerAvailability",
                "ecr:BatchGetImage",
                "ecr:BatchGetRepositoryScanningConfiguration",
                "ecr:DescribeImageReplicationStatus",
                "ecr:DescribeImageScanFindings",
                "ecr:DescribeRepositories",
                "ecr:GetDownloadUrlForLayer",
                "ecr:GetLifecyclePolicy",
                "ecr:GetLifecyclePolicyPreview",
                "ecr:GetRegistryScanningConfiguration",
                "ecr:GetRepositoryPolicy",
                "ecr:ListTagsForResource",
                "ecr:TagResource",
                "ecr:UntagResource",
                "ecr:BatchDeleteImage",
                "ecr:BatchImportUpstreamImage",
                "ecr:CompleteLayerUpload",
                "ecr:CreatePullThroughCacheRule",
                "ecr:CreateRepository",
                "ecr:DeleteLifecyclePolicy",
                "ecr:DeletePullThroughCacheRule",
                "ecr:DeleteRepository",
                "ecr:InitiateLayerUpload",
                "ecr:PutImage",
                "ecr:PutImageScanningConfiguration",
                "ecr:PutImageTagMutability",
                "ecr:PutLifecyclePolicy",
                "ecr:PutRegistryScanningConfiguration",
                "ecr:ReplicateImage",
                "ecr:StartImageScan",
                "ecr:StartLifecyclePolicyPreview",
                "ecr:UploadLayerPart",
                "ecr:DeleteRepositoryPolicy",
                "ecr:SetRepositoryPolicy"
            ],
            "Resource": [
                "arn:aws:ecr:${AWS_REGION}:${AWS_ACCOUNT_ID}:repository/full-deps-package-repo",
                "arn:aws:ecr:${AWS_REGION}:${AWS_ACCOUNT_ID}:repository/tap-build-service",
                "arn:aws:ecr:${AWS_REGION}:${AWS_ACCOUNT_ID}:repository/tap-images"
            ],
            "Effect": "Allow",
            "Sid": "TAPEcrBuildServiceScoped"
        }
    ]
}
EOF

cat << EOF > workload-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Action": [
                "ecr:DescribeRegistry",
                "ecr:GetAuthorizationToken",
                "ecr:GetRegistryPolicy",
                "ecr:PutRegistryPolicy",
